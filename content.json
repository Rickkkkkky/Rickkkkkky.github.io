{"meta":{"title":"Ricky's Blog","subtitle":null,"description":null,"author":"Ricky","url":"https://Rickkkkkky.github.io"},"pages":[],"posts":[{"title":"理解 JavaScript 中的 Promise","slug":"Tech Notes/JavaScript Essence/理解 JavaScript 中的 Promise","date":"2019-06-20T08:00:00.000Z","updated":"2019-07-16T03:40:30.132Z","comments":true,"path":"posts/977c1ee025c5154f.html","link":"","permalink":"https://Rickkkkkky.github.io/posts/977c1ee025c5154f.html","excerpt":"Promise 规范 Promise 是异步编程的一种解决方案，具体规范可以参考 Promise/A+ 规范。ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 类。","text":"Promise 规范 Promise 是异步编程的一种解决方案，具体规范可以参考 Promise/A+ 规范。ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 类。 本文将主要通过翻译、解读 Promise/A+ 规范来理解 Promise。 规范术语 为了方便理解，本文在描述时会直接引用 Promise/A+ 规范中定义的术语。 &quot;promise&quot; 表示包含了兼容 Promise/A+ 规范的 then() 方法的对象或者函数，通常指一个 Promise 实例。 &quot;thenable&quot; 表示包含了 then() 方法的对象或者函数。 &quot;value&quot; 表示合法的 JavaScirpt 值（包括 undefined、&quot;thenable&quot; 或 &quot;promise&quot;）。 &quot;exception&quot; 表示由 throw 表达式抛出的 &quot;value&quot;。 &quot;reason&quot; 指一个表示 &quot;promise&quot; 状态变为 rejected 原因的 &quot;value&quot;。 &quot;promise&quot; 的含义 一个 &quot;promise&quot; 表示一个操作（通常是异步操作，但也可以是同步操作）的最终结果。 &quot;promise&quot; 的状态 一个 &quot;promise&quot; 的状态是只能是 pending（进行中）、fulfilled（已成功）或 rejected（已失败）这三种中的一种。其中 pending 是未完成状态，fulfilled 和 rejected 都是完成状态（可以统称为 settled 或 resolved 状态）。 当 &quot;promise&quot; 的状态为 pending 时，表示操作未完成。此时 &quot;promise&quot; 的状态可以转化为 fulfilled 或 rejected。 当 &quot;promise&quot; 的状态为 fulfilled 时，表示操作已成功。此时 &quot;promise&quot; 的状态不能再改变，并且 &quot;promise&quot; 包含一个不可变的 &quot;value&quot; 表示操作成功的结果（下文中称为 &quot;promise&quot; 的成功结果）。 当 &quot;promise&quot; 的状态为 rejected 时，表示操作已失败。此时 &quot;promise&quot; 的状态不能再改变，并且 &quot;promise&quot; 包含一个不可变的 &quot;reason&quot; 表示操作失败的原因（下文中称为 &quot;promise&quot; 的失败原因）。 这里的所指的 &quot;不可变&quot; 是指 &quot;value&quot; 的 &quot;值&quot; 是不可修改的，对于引用类型值，仍然可以修改它的属性。 then() 方法 then() 方法是与 &quot;promise&quot; 进行交互的最主要途径，用于注册 &quot;promise&quot; 的状态由 pending 变为 fulfilled 或 rejected 的回调函数，并通过回调函数来获取 &quot;promise&quot; 的 &quot;value&quot; 或 &quot;reason&quot;。 1Promise.prototype.then(onFulfilled, onRejected) onFulfilled 是可选的参数，如果它的值不是函数则会被忽略。如果 onFulfilled 是一个函数，则它只能在 &quot;promise&quot; 的状态变为 fulfilled 后被调用，传递给 onFulfilled() 的参数是 &quot;promise&quot; 的成功结果。 onRejected 是可选的参数，如果它的值不是函数则会被忽略。如果 onRejected 是一个函数，则它只能在 &quot;promise&quot; 的状态变为 rejected 后被调用，传递给 onRejected() 的参数是 &quot;promise&quot; 的失败原因。 一个 &quot;promise&quot; 可以多次调用 then() 方法，当 &quot;promise&quot; 的状态转换为 fulfilled 或 rejected 后，所有的 onFulfilled() 或 onRejected() 会按照其注册顺序依次调用。 then() 方法会返回一个 &quot;promise&quot;。 1promise2 = promise1.then(onFulfilled, onRejected) 不论 promise1 的状态最终变为了什么，假设这个状态对应的参数（onFulfilled 或 onRejected）为 callback，则： 如果 callback 是函数并且返回一个值，假设返回值为 x，调用 [[Resolve]](promise2, x) 来判断 promise2 的最终状态和结果； 如果 callback 是函数并且抛出一个异常 e，promise2 的状态将变为 rejected，它的失败原因为 e； 如果 callback 不是函数，则 promise2 的最终状态和最终结果与 promise1 相同。 这里的 [[Resolve]](promise, x) 是规范中定义的一个抽象的操作，在规范中称之为 &quot;Promise Resolution Procedure&quot;。 Promise Resolution Procedure &quot;Promise Resolution Procedure&quot; 用 [[Resolve]](promise, x) 表示，它接受一个 &quot;promise&quot; 和一个 &quot;value&quot; 作为输入参数。如果 x 是一个 &quot;thenable&quot;，那么会尝试让 promise 与 x 的状态保持一致；否则 promise 的状态变为 fulfilled，它的成功结果为 x 的值。 这里的 &quot;promise&quot; 指的是前文中引用的规范中的术语，而 promise 指的是传入 [[Resolve]](promise, x) 中的参数。 [[Resolve]](promise, x) 的大致执行逻辑为： 如果 x 不是 thenable，以 x 作为成功结果将 promise 的状态变为 fulfilled； 如果 x 是 thenable，则： 如果 promise 与 x 引用的是同一个对象，以一个 TypeError 作为失败原因将 promise 的状态变为 rejected； 如果 x 是一个 &quot;promise&quot;，则 promise 的状态和最终结果与 x 保持一致； 如果获取 x.then 的值时抛出错误 e，则以 e 作为失败原因将 promise 的状态变为 rejected； 如果 x.then 是一个函数，则执行 x.then(resolvePromise, rejectPromise)： 如果 resolvePromise 被调用，假设传入的参数为 y，则执行 [[Resolve]](promise, y)； 如果 rejectPromise 被调用，假设传入的参数为 r，则以 r 为失败原因将 promise 的状态变为 rejected； 无论 resolvePromise 和 rejectPromise 被调用多少次，只以第一次调用为准，后续的调用会被忽略； 如果执行 x.then() 的过程中抛出异常 e，若此时 resolvePromise 或 rejectPromise 已经被调用，则忽略该异常；否则以 e 为失败原因将 promise 的状态变为 rejected。","categories":[{"name":"Tech Notes","slug":"Tech-Notes","permalink":"https://Rickkkkkky.github.io/categories/Tech-Notes/"},{"name":"JavaScript Essence","slug":"Tech-Notes/JavaScript-Essence","permalink":"https://Rickkkkkky.github.io/categories/Tech-Notes/JavaScript-Essence/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://Rickkkkkky.github.io/tags/JavaScript/"}]},{"title":"理解 JavaScript 中的事件循环","slug":"Tech Notes/JavaScript Essence/理解 JavaScript 中的事件循环","date":"2019-04-19T08:00:00.000Z","updated":"2019-07-12T08:34:17.560Z","comments":true,"path":"posts/99bdc41f3fe568a2.html","link":"","permalink":"https://Rickkkkkky.github.io/posts/99bdc41f3fe568a2.html","excerpt":"主线程与工作线程 JavaScript 的一个核心特征就是单线程。当我们说 &quot;JavaScript 是单线程语言&quot; 时，我们实际上想表达的意思是 &quot;JavaScript 引擎中负责解释和执行 JavaScript 代码的线程只有一个&quot;。我们将这个线程称为主线程。 由于 JavaScript 是单线程的，主线程在同一时刻只能执行一个任务。对于一些耗时较长的任务（如 I/O 操作），如果将其放在主线程中运行，势必会造成主线程阻塞。因此这些较为耗时的操作不能放在主线程上执行，需要其他线程帮助主线程处理这些任务，例如处理 Ajax 请求的线程、定时器线程、处理 DOM 事件的线程、（Node.js中）文件读写的线程等。我们将这些线程统一称为工作线程。","text":"主线程与工作线程 JavaScript 的一个核心特征就是单线程。当我们说 &quot;JavaScript 是单线程语言&quot; 时，我们实际上想表达的意思是 &quot;JavaScript 引擎中负责解释和执行 JavaScript 代码的线程只有一个&quot;。我们将这个线程称为主线程。 由于 JavaScript 是单线程的，主线程在同一时刻只能执行一个任务。对于一些耗时较长的任务（如 I/O 操作），如果将其放在主线程中运行，势必会造成主线程阻塞。因此这些较为耗时的操作不能放在主线程上执行，需要其他线程帮助主线程处理这些任务，例如处理 Ajax 请求的线程、定时器线程、处理 DOM 事件的线程、（Node.js中）文件读写的线程等。我们将这些线程统一称为工作线程。 异步过程 异步的意义在于：工作线程执行任务时，主线程同时也可以继续执行其他任务。 我们可以将异步过程大致归纳为： 主线程发起异步任务请求； 相应的工作线程接收异步任务请求，并通知主线程； 工作线程执行相应的任务，同时主线程继续执行其他任务； 工作线程完成任务后通知主线程； 主线程执行异步任务的回调。 举个例子： 1234567console.log('script start')setTimeout(() =&gt; &#123; console.log('timeout')&#125;, 1000)console.log('script end') 上面这段代码在控制台的输出为： 123script startscript endtimeout 控制台首先输出了 script start 和 script end，之后经过了大概 1 秒的时间后输出了 timeout。 当主线程调用 setTimeout() 时，会向定时器的工作线程发送异步任务请求，而后继续执行之后的任务。因此控制台中 script end 会在 timeout 之前被输出。 再举个例子： 12345678910console.log('script start')setTimeout(() =&gt; &#123; console.log('timeout')&#125;, 1000)const startTime = new Date().getTime()while (new Date().getTime() - startTime &lt;= 10000) &#123;&#125;console.log('script end') 这个例子与之前的例子很相似。不同之处在于，调用 setTimeout() 并设置一个延迟 1 秒执行的异步任务之后，我们通过一个 while 循环判断时间是否经过了 10 秒。观察控制台的输出: 123script startscript endtimeout 控制台首先输出了 script start，之后经过了大概 10 秒的时间后输出了 script end 和 timeout。 这个结果有趣的点在于，虽然 setTimeout() 设置的延迟时间只有 1 秒，但实际上它的回调函数执行的时间却延迟了大约 10 秒。所以问题的关键点在于，异步过程中工作线程与主线程是通过怎么样的机制进行沟通的？ 调用栈、任务队列与事件循环 JavaScript 运行时维护了一个调用栈（Call Stack）与任务队列（Task Queue）。 调用栈是 JavaScript 追踪函数执行流的一种机制。 每调用一个函数，解释器就会把该函数添加进调用栈并开始执行。 如果正在调用栈中执行的函数还调用了其他函数，那么新函数也将会被添加进调用栈，并开始执行。 当前函数执行完毕后，会将该函数从调用栈中移除，并继续执行当前执行环境中剩下的代码。 任务队列则是工作线程在异步任务完成之后通知主线程的通知机制。当工作线程完成异步任务后，相应的任务会被添加到任务队列中。 主线程执行任务队列中的任务是一个循环的过程，称为事件循环。当调用栈为空时，任务队列中最先进入队列的任务会被移出队列，并传递给主线程，回调函数进入调用栈开始执行。 GUI 渲染线程 浏览器内核中包含了一个 GUI 渲染线程，它负责渲染图形用户界面。 值得注意的是，浏览器的 GUI 渲染线程与执行 JavaScript 代码的主线程是互斥的，当主线程执行 JavaScript 时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中。GUI 渲染线程会在 JavaScript 主线程的事件循环的间隔中执行 GUI 的更新。 举个例子： 123456document.body.style['background-color'] = '#000'const startTime = new Date().getTime()while (new Date().getTime() - startTime &lt;= 10000) &#123;&#125;document.body.style['background-color'] = '#fff' 在浏览器中运行上面的例子，我们会发现页面的背景色并没有像我们预期的一样首先变为黑色，经过 10 秒后再变为白色。产生这样的结果的原因在于，两次修改页面背景色的操作实际上是在一次事件循环中执行的，这个过程中 GUI 渲染线程并不会立即执行 GUI 的更新。 修改上面的例子： 12345document.body.style['background-color'] = '#000'setTimeout(() =&gt; &#123; document.body.style['background-color'] = '#fff'&#125;, 10000) 这个例子中，我们将两次修改页面背景色的操作放在两次事件循环中执行，页面的背景色首先变为黑色，在经过大约 10 秒之后变为了白色。当修改页面背景色为黑色并且当前调用栈执行完毕后，GUI 渲染线程执行 GUI 更新。定时器线程在 10 秒的延迟后向任务队列推送任务。主线程获取到任务以后开始新一轮的事件循环，将页面的背景色设为白色，而后本轮事件循环结束，GUI 渲染线程再次执行 GUI 更新。 Web Worker 由于 JavaScript 单线程的机制，当调用栈中执行的代码需要消耗较长的时间时，任务队列中的任务就必须等待，直到这些较为耗时的操作执行完毕后才能被处理；并且，GUI 渲染也会被阻塞，GUI 会长时间得不到更新。 为了解决上面提出的问题，浏览器提供了 Web Worker API，可以将较为耗时的操作分配到其他线程中。当创建一个 Worker 实例时，JavaScript 引擎就会向浏览器申请一个子线程，我们将其称为 Web Worker 线程。Web Worker 线程具有独立的运行时，主线程与 Web Worker 线程之间通过 postMessage() 向对方推送消息。 微任务 举个例子： 12345678910111213141516console.log('script start')setTimeout(() =&gt; &#123; console.log('timeout')&#125;, 100)const startTime = new Date().getTime()while (new Date().getTime() - startTime &lt;= 10000) &#123;&#125;Promise.resolve().then(() =&gt; &#123; console.log('first promise')&#125;).then(() =&gt; &#123; console.log('second promise')&#125;)console.log('script end') 上面的例子中，正确的输出顺序是： 12345script startscript endfirst promisesecond promisetimeout 为什么 timeout 会在最后被输出呢？ 事实上，在 JavaScript 的运行机制中，除了任务队列以外，还存在一个微任务（microtask）队列。微任务队列与任务队列的不同之处在于，在调用栈为空时，主线程会优先从微任务队列中获取待执行的任务，只有当调用栈和微任务队列都为空时，主线程才会执行任务队列中的任务。 微任务产生的途径包括： Promise MutationObserver Object.observe（已废弃） process.nextTick()（Node.js API） 当某次事件循环中产生了微任务，微任务会被添加到微任务队列中。当调用栈为空时，微任务队列中的微任务按顺序被执行。当调用栈和微任务队列都为空时，本次事件循环结束，GUI 渲染线程渲染用户图形界面，而后开始下一轮事件循环。 参考内容 Tasks, microtasks, queues and schedules The JavaScript Event Loop: Explained","categories":[{"name":"Tech Notes","slug":"Tech-Notes","permalink":"https://Rickkkkkky.github.io/categories/Tech-Notes/"},{"name":"JavaScript Essence","slug":"Tech-Notes/JavaScript-Essence","permalink":"https://Rickkkkkky.github.io/categories/Tech-Notes/JavaScript-Essence/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://Rickkkkkky.github.io/tags/JavaScript/"}]},{"title":"JavaScript 实现继承的常用模式","slug":"Tech Notes/JavaScript 实现继承的常用模式","date":"2019-04-11T08:00:00.000Z","updated":"2019-07-12T08:35:26.118Z","comments":true,"path":"posts/666b8730271d1bfc.html","link":"","permalink":"https://Rickkkkkky.github.io/posts/666b8730271d1bfc.html","excerpt":"原型链 JavaScript 允许对象访问其原型链中的原型对象的属性，因此能够通过原型链实现继承。 1234567891011121314151617function SuperType () &#123; this.superProperty = true&#125;SuperType.prototype.saySuperValue = function () &#123; console.log(this.superProperty)&#125;function SubType () &#123; this.subProperty = false&#125;SubType.prototype = new SuperType()SubType.prototype.saySubValue = function () &#123; console.log(this.subProperty)&#125; 通过原型链实现继承的基本模式是让子类型的原型指向超类型的一个实例。","text":"原型链 JavaScript 允许对象访问其原型链中的原型对象的属性，因此能够通过原型链实现继承。 1234567891011121314151617function SuperType () &#123; this.superProperty = true&#125;SuperType.prototype.saySuperValue = function () &#123; console.log(this.superProperty)&#125;function SubType () &#123; this.subProperty = false&#125;SubType.prototype = new SuperType()SubType.prototype.saySubValue = function () &#123; console.log(this.subProperty)&#125; 通过原型链实现继承的基本模式是让子类型的原型指向超类型的一个实例。 12const instance = new SubType()instance.saySuperValue() // true 这种方式存在的问题在于： 创建子类型实例时，无法给超类型的构造函数传递参数。 子类型访问继承的引用类型值并进行一些操作时，可能会影响其他实例。 123456789101112131415161718192021function Person (name) &#123; this.name = name this.friends = []&#125;function Man () &#123;&#125;Man.prototype = new Person()const man1 = new Man('Ricky')const man2 = new Man()console.log(man1.name) // undefinedman1.friends.push('Ricky')console.log(man1.friends) // ['Ricky']console.log(man2.friends) // ['Ricky']man1.friends = ['Mike']console.log(man1.friends) // ['Mike']console.log(man2.friends) // ['Ricky'] 借用构造函数 借用构造函数（constructor stealing，也叫作伪造对象或经典继承）的基本思想就是在子类型构造函数的内部调用超类型的构造函数。 123456789101112131415161718function Person (name) &#123; this.name = name this.friends = []&#125;function Man (name) &#123; Person.call(this, name)&#125;const man1 = new Man('Ricky')const man2 = new Man('Mike')console.log(man1.name) // Rickyconsole.log(man2.name) // Mikeman1.friends.push('Mike')console.log(man1.friends) // ['Mike']console.log(man2.friends) // [] 借用构造函数模式可以解决使用原型链实现继承时存在的问题。但是，如果仅仅使用借用构造函数的模式实现继承，会产生一定的局限性： 方法都在构造函数中定义，会导致函数重复创建，无法复用。 子类型的实例无法访问超类型的原型。 123456789101112131415161718192021222324function Person (name) &#123; this.name = name&#125;Person.prototype.sayName = function () &#123; console.log(this.name)&#125;function Man (name) &#123; Person.call(this, name) this.sayGender = function () &#123; console.log('MALE') &#125;&#125;const man1 = new Man('Ricky')const man2 = new Man('Mike')man1.sayGender() // MALEman2.sayGender() // MALEconsole.log(man1.sayGender === man2.sayGender) // falseman1.sayName() // TypeError: man1.sayName is not a function 组合继承 组合继承（combination inheritance，也叫伪经典继承）是指将原型链与借用构造函数方法组合在一起的一种继承模式，弥补了这两种方法各自的缺陷。 1234567891011121314151617181920212223242526272829303132function Person (name) &#123; this.name = name this.friends = []&#125;Person.prototype.sayName = function () &#123; console.log(this.name)&#125;function Man (name) &#123; Person.call(this, name)&#125;Man.prototype = new Person('')Man.prototype.constructor = ManMan.prototype.sayGender = function () &#123; console.log('MALE')&#125;const man1 = new Man('Ricky')const man2 = new Man('Mike')man1.sayGender() // MALEman2.sayGender() // MALEconsole.log(man1.sayGender === man2.sayGender) // trueman1.sayName() // Rickyman2.sayName() // Mikeman1.friends.push('Mike')console.log(man1.friends) // ['Mike']console.log(man2.friends) // [] 原型式继承 原型式（prototypal）继承的基本思想是借助原型，基于已有的对象创建新对象，同时避免了创建新的自定义类型。它的简单实现参考以下函数： 12345function prototypalInherit (object) &#123; const F = function () &#123;&#125; F.prototype = object return new F()&#125; 如果我们将传入的参数 object 视为超类型的一个实例，F 视为子类型，那么实际上原型式继承可以视为原型链实现继承的简化和封装。 ES 标准中通过 Object.create() 方法规范化了原型式继承。 1Object.create(proto, [propertiesObject]) 寄生式继承 寄生式（parasitic）继承时原型式继承的延伸，实际上是对原型式继承的二次封装。 1234567function parasiticInherit (object) &#123; const newObject = prototypalInherit(object) // 对新对象进行扩展，为其添加属性和方法 return newObject&#125; 寄生组合式继承 组合继承避免了原型链继承和借用构造函数的缺陷，但组合继承的实现中调用了两次超类型构造函数：一次是在创建子类型原型时，一次是在子类型构造函数内部。在第一次调用时子类型原型会包含超类型对象的全部实例属性，这些属性都是多余的，因为在第二次调用超类型构造函数时子类型的实例会屏蔽这些存在于子类型原型中的同名属性。 可以通过原型式继承的思想避免在子类型原型上创建多余的属性。 12345function inheritPrototype (SuperType, SubType) &#123; const prototype = prototypalInherit(SuperType.prototype) prototype.constructor = SubType SubType.prototype = prototype&#125; 上面的方法通过原型式继承创建了子类型的原型，并对原型进行了扩展，在这个过程中避免了调用超类型的构造函数。这种方法称为寄生组合式继承。","categories":[{"name":"Tech Notes","slug":"Tech-Notes","permalink":"https://Rickkkkkky.github.io/categories/Tech-Notes/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://Rickkkkkky.github.io/tags/JavaScript/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://Rickkkkkky.github.io/tags/Design-Pattern/"}]},{"title":"理解 JavaScript 中的原型对象","slug":"Tech Notes/JavaScript Essence/理解 JavaScript 中的原型对象","date":"2019-03-21T08:00:00.000Z","updated":"2019-07-12T08:34:40.162Z","comments":true,"path":"posts/01da5b9cbaee6b5f.html","link":"","permalink":"https://Rickkkkkky.github.io/posts/01da5b9cbaee6b5f.html","excerpt":"原型和原型对象 All ordinary objects have an internal slot called [[Prototype]]. The value of this internal slot is either null or an object and is used for implementing inheritance. Data properties of the [[Prototype]] object are inherited (and visible as properties of the child object) for the purposes of get access, but not for set access. Accessor properties are inherited for both get access and set access. – Ordinary Object Internal Methods and Internal Slots 在 ES 标准中，所有的普通对象都有一个用于实现继承的内部属性，称为 [[Prototype]]，它的值是 null 或者一个 object 类型的值。对象访问 [[Prototype]] 对象的数据属性时，只能获取属性的值而不能对属性进行赋值（只能以 get 访问器的形式访问属性）；访问 [[Prototype]] 对象的访问器属性时，属性的 get 和 set 访问器都是允许访问的。","text":"原型和原型对象 All ordinary objects have an internal slot called [[Prototype]]. The value of this internal slot is either null or an object and is used for implementing inheritance. Data properties of the [[Prototype]] object are inherited (and visible as properties of the child object) for the purposes of get access, but not for set access. Accessor properties are inherited for both get access and set access. – Ordinary Object Internal Methods and Internal Slots 在 ES 标准中，所有的普通对象都有一个用于实现继承的内部属性，称为 [[Prototype]]，它的值是 null 或者一个 object 类型的值。对象访问 [[Prototype]] 对象的数据属性时，只能获取属性的值而不能对属性进行赋值（只能以 get 访问器的形式访问属性）；访问 [[Prototype]] 对象的访问器属性时，属性的 get 和 set 访问器都是允许访问的。 原型对象的创建与绑定过程 当创建一个函数时，会为其创建一个 prototype 属性； 同时，还会创建一个默认的包含 constructor 属性的对象作为函数的原型； 赋值：函数的 prototype 属性 = 函数的原型；函数原型的 constructor 属性 = 该函数自身； 通过 new 操作符调用函数创建的实例，其 [[Prototype]] 属性 = 函数的 prototype 属性。 如果函数的 prototype 属性赋值为其他对象，新的原型不会像默认的原型一样自动创建一个不可枚举的 constructor 属性；可以使用 Object.defineProperty() 方法为原型创建 constructor 属性。 值得注意的是，ES6 中的箭头函数没有 prototype 属性。 为了避免混淆，本文将函数的 prototype 属性称为函数的原型；将对象的 [[Prototype]] 内部属性称为该对象的原型对象。 与原型对象相关的方法 原型对象是连接构造函数与其实例之间的桥梁。但由于 [[Prototype]] 是内部属性，因此不能直接访问（部分浏览器在对象上实现了一个 __proto__ 属性指向原型对象）。 Object.prototype.isPrototypeOf(object) - 判断调用 isPrototypeOf() 方法的对象是否在 object 的原型链上。 Object.getPrototypeOf(object) - 返回 object 的原型对象。 Object.create(proto, [propertiesObject]) - 创建一个新对象，并将 proto 作为该对象的原型对象。 原型和原型对象的关系 原型和原型对象的关系如下图所示。一般情况下，函数的原型与该函数的实例的原型对象实际上是同一个对象。 Function 和 Object 的原型对象 函数作为一个引用类型的值，它的原型对象是 Function.prototype。 123456function People () &#123;&#125;const people = new People()console.log(Object.getPrototypeOf(people) === People.prototype) // trueconsole.log(Object.getPrototypeOf(People) === Function.prototype) // true Function 和 Object 本身也是一个函数，因此它们的原型对象也是 Function.prototype。 1234console.log(Object.getPrototypeOf(Function) === Function.prototype) // trueconsole.log(Function instanceof Function) // trueconsole.log(Object.getPrototypeOf(Object) === Function.prototype) // trueconsole.log(Object instanceof Function) // true 那么，这是不是就意味着 Function 是 Function 的实例呢？ 这个问题看似是类似于“鸡生蛋，蛋生鸡”的问题，但实际上，Function 是 ES 标准中的内置对象，是在代码运行之前就存在的，所以 Function 本身并不是通过 Function 创建的。但 Function 本身也是一个函数，因此语言在设计上让 Function 的原型对象为 Function.prototype。 原型链 对象属性的搜索过程 当访问对象的属性时，会首先从该对象本身开始进行搜索，如果在对象上找到了所搜索的属性，则返回该属性的值；如果没有找到，则继续搜索该对象的原型对象。可以将对象属性的搜索过程视为一个递归的过程。 1234567891011// 抽象化描述对象属性的搜索过程function search (object, prop) &#123; const proto = Object.getPrototypeOf(object) if (object.hasOwnProperty(prop)) &#123; return object.getOwnPropertyDescriptor(prop) &#125; else if (proto) &#123; search(proto, prop) &#125; else &#123; return undefined &#125;&#125; 上面的函数简单描述了对象属性的搜索过程。由于一个对象的原型对象也拥有自己的原型对象，这种层层递进的关系就构成了原型链。 123456789101112131415161718192021function People (name) &#123; this.name = name || ''&#125;People.prototype.sayName = function () &#123; console.log(this.name)&#125;function Man (name) &#123; People.call(this, name)&#125;Man.prototype = new People()Man.prototype.constructor = ManMan.prototype.sayGender = function () &#123; console.log('MALE')&#125;let man = new Man('Ricky')Man.sayGender() // MALEman.sayName() // Ricky 上面的示例中，Man 的实例的原型对象是 Man.prototype，而 Man 的原型又是 People 的实例，因此 Man.prototype 的原型对象是 People.prototype。People.prototype 是创建函数的时候生成的，它的原型对象是 Object.prototype。 修改原型 在原型链中查找属性值的过程是一次运行时的搜索过程，因此当原型的属性变化时，这些变化能够立即反映在已经创建的实例上。 123456789function Man () &#123;&#125;const man = new Man()console.log(man.gender) // undefinedMan.prototype.gender = 'MALE'console.log(man.gender) // MALE 但是，当函数的 prototype 属性引用一个新对象时，已经创建的实例的 [[Prototype]] 内部属性所引用的对象不会发生改变。 12345678910111213function Man () &#123;&#125;const man1 = new Man()Man.prototype = &#123; constructor: Man, gender: 'MALE'&#125;const man2 = new Man()console.log(man1.gender) // undefinedconsole.log(man2.gender) // MALE 原型链的终点 JavaScript 中的引用类型值都是 Object 类型的，但事实上，所有原型链的终点都是 null，而不是 Object.prototype。 123const obj = &#123;&#125;console.log(Object.getPrototypeOf(obj) === Object.prototype) // trueconsole.log(Object.getPrototypeOf(Object.prototype)) // null 在 ES 标准中值得注意的一点： If Type(proto) is not Object, set the [[Prototype]] internal property of obj to the standard built-in Object prototype object 如果函数的原型不是引用类型的值，通过 new 操作符调用构造函数时，创建的实例的原型对象实际上是 Object.prototype。 12345function People () &#123;&#125;People.prototype = nullconst people = new People()console.log(Object.prototype.isPrototypeOf(people)) // trueconsole.log(People.isPrototypeOf(people)) // false 可以通过 Object.create() 方法创建没有原型链的对象。 12const object = Object.create(null)console.log(Object.getPrototypeOf(object)) // null 参考内容 Annotated ECMAScript 5","categories":[{"name":"Tech Notes","slug":"Tech-Notes","permalink":"https://Rickkkkkky.github.io/categories/Tech-Notes/"},{"name":"JavaScript Essence","slug":"Tech-Notes/JavaScript-Essence","permalink":"https://Rickkkkkky.github.io/categories/Tech-Notes/JavaScript-Essence/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://Rickkkkkky.github.io/tags/JavaScript/"}]},{"title":"JavaScript 实现函数防抖与函数节流","slug":"Tech Notes/JavaScript 实现函数防抖与函数节流","date":"2019-03-19T08:00:00.000Z","updated":"2019-07-12T08:34:52.771Z","comments":true,"path":"posts/001aa9d7541f3ee9.html","link":"","permalink":"https://Rickkkkkky.github.io/posts/001aa9d7541f3ee9.html","excerpt":"函数防抖 函数防抖（debounce）的基本概念是在函数频繁被调用的情况下，只有函数调用的时间间隔超过指定间隔的时候，函数的逻辑才执行。 使用场景 用户输入后验证表单或查询搜索； 判断滚动条是否滑动到底部；","text":"函数防抖 函数防抖（debounce）的基本概念是在函数频繁被调用的情况下，只有函数调用的时间间隔超过指定间隔的时候，函数的逻辑才执行。 使用场景 用户输入后验证表单或查询搜索； 判断滚动条是否滑动到底部； 简单实现 12345678910const debounce = (fn, delay) =&gt; &#123; let timer = null return (...args) =&gt; &#123; const ctx = this clearTimeout(timer) timer = setTimeout(() =&gt; &#123; fn.apply(ctx, args) &#125;, delay) &#125;&#125; 函数节流 函数节流（throttle）是指在指定的时间范围内，函数的逻辑只执行一次。 使用场景 DOM 拖拽； 窗口 resize； 简单实现 1234567891011121314151617const throttle = (fn, gap) =&gt; &#123; let timer = null let start = new Date().getTime() return (...args) =&gt; &#123; const ctx = this const current = new Date().getTime() clearTimeout(timer) if (current - start &gt;= gap) &#123; fn.apply(ctx, args) start = current &#125; else &#123; timer = setTimeout(() =&gt; &#123; fn.apply(ctx, args) &#125;, gap) &#125; &#125;&#125; 两者的区别 1234567891011121314151617const sayDebounce = debounce(() =&gt; &#123; console.log('Debounce')&#125;, 100)let i = 0while (i &lt; 100000) &#123; sayDebounce() i++&#125;const sayThrottle = throttle(() =&gt; &#123; console.log('Throttle')&#125;, 100)i = 0while (i &lt; 100000) &#123; sayThrottle() i++&#125; 上面的例子中，控制台输出了 1 次 'Debounce' 和 8 次 'Throttle'（结果因设备而异）。 函数防抖在函数被连续调用的情况下，只要相邻两次调用的时间间隔不超过设定的阈值，就只有最后一次函数调用会执行函数逻辑；而函数节流则不管函数调用的时间间隔，它保证函数在一段时间范围内一定会执行并且只执行一次。","categories":[{"name":"Tech Notes","slug":"Tech-Notes","permalink":"https://Rickkkkkky.github.io/categories/Tech-Notes/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://Rickkkkkky.github.io/tags/JavaScript/"}]},{"title":"理解 JavaScript 中的函数调用","slug":"Tech Notes/JavaScript Essence/理解 JavaScript 中的函数调用","date":"2019-01-09T08:00:00.000Z","updated":"2019-07-12T08:32:19.403Z","comments":true,"path":"posts/12ceb9eac8b09893.html","link":"","permalink":"https://Rickkkkkky.github.io/posts/12ceb9eac8b09893.html","excerpt":"通过 call() 方法调用 1Function.prototype.call(thisArg, ...args) Function 原型对象上的 call() 方法接收一个 thisArg 和可选的 arg1、arg2 等作为参数。调用函数时，将 this 的值根据 thisArg 进行设置，并将其余参数传递给发生调用的函数。","text":"通过 call() 方法调用 1Function.prototype.call(thisArg, ...args) Function 原型对象上的 call() 方法接收一个 thisArg 和可选的 arg1、arg2 等作为参数。调用函数时，将 this 的值根据 thisArg 进行设置，并将其余参数传递给发生调用的函数。 12345678910function sayName (before, after) &#123; console.log(before + this.name + after)&#125;var person = &#123; name: 'Ricky'&#125;sayName.call(person, 'My name is ', '.')// 'My name is Ricky.' 在非严格模式下，当传递给 thisArg 参数的值是基本数据类型时，会将其进行转换后再设置为函数调用时 this 的值。 当 thisArg 为 undefined 或者 null 时，则在函数调用时会将 Global 对象作为 this 的值。在浏览器环境下，Global 对象是作为 window 对象的一部分加以实现的；在 Node 环境下，Global 对象是指 global 全局变量。 当 thisArg 为 Boolean、Number 或 String 类型的值时，会将参数值转换成的对应的基本包装类型的对象作为 this 的值。 12345678910111213function [a-zA-Z][a-zA-z0-9]+ \\() &#123; console.log(this + ' is a/an ' + typeof this)&#125;sayType.call(undefined) // '[object Window] is a/an object'sayType.call(null) // '[object Window] is a/an object'sayType.call(false) // 'false is a/an object'sayType.call(2) // '2 is a/an object'sayType.call('abc') // 'abc is a/an object' 在严格模式下，传递给 thisArg 参数的值会直接作为函数调用时 this 的值。 123456789101112131415'use strict'function sayType () &#123; console.log(this + ' is a/an ' + typeof this)&#125;sayType.call(undefined) // 'undefined is a/an undefined'sayType.call(null) // 'null is a/an object'sayType.call(false) // 'false is a/an boolean'sayType.call(2) // '2 is a/an number'sayType.call('abc') // 'abc is a/an string' Function 的原型对象上还提供了一个 apply() 方法，它和 call() 方法的作用基本相同，区别只在于函数调用的参数是以数组的形式传递给 apply() 方法的。 直接调用 123456789101112131415161718function sayName () &#123; console.log(this.name)&#125;window.name = 'Window'// 直接调用sayName() // 'Window'// 等同于sayName.call(undefined) // 'Window'function sayThis () &#123; 'use strict' console.log(this)&#125;sayThis() // undefined 直接调用函数时，等同于将 undefined 作为 call() 方法的 thisArg 参数的值来调用函数。 作为对象方法调用 当函数作为对象的方法调用时，等同于将这个对象作为 call() 方法的 thisArg 参数的值来调用函数。 12345678910111213141516171819202122232425function sayName () &#123; console.log(this.name)&#125;var person = &#123; name: 'Ricky', sayName: sayName&#125;// 作为对象方法调用person.sayName() // 'Ricky'// 等同于person.sayName.call(person) // 'Ricky'var language = &#123; name: 'JavaScript'&#125;language.sayName = sayName// 作为对象方法调用language.sayName() // 'JavaScript'// 等同于language.sayName.call(language) // 'JavaScript' bind() 方法 this 值的绑定发生在函数调用的时候，因此函数可以对 this 进行复用。但是有些时候出于方便考虑，我们希望能够将函数中 this 的值持久化。 12345678910111213function sayName () &#123; console.log('My name is ' + this.name + '.')&#125;var person = &#123; name: 'Ricky'&#125;function personSayName () &#123; sayName.call(person)&#125;personSayName() // 'My name is Ricky.' 我们可以简单地将这种技巧封装成通用的函数。 1234567891011121314151617function bind (func, thisArg) &#123; return function () &#123; return func.apply(thisArg, arguments) &#125;&#125;function sayName () &#123; console.log('My name is ' + this.name + '.')&#125;var person = &#123; name: 'Ricky'&#125;var personSayName = bind(sayName, person)personSayName() // 'My name is Ricky.' Function 的原型对象提供了 bind() 方法来实现函数和 this 值的持久绑定。 1234567891011function sayName () &#123; console.log('My name is ' + this.name + '.')&#125;var person = &#123; name: 'Ricky'&#125;var personSayName = sayName.bind(person)personSayName() // 'My name is Ricky.' 内置方法 [[Call]] 对比 ES 标准中的 Function.prototype.call 小节对于 call() 方法的定义以及 Function Calls 小节对于函数调用的定义，我们可以看出，实际上 [obj.]func() 和 func.call() 最终都是通过调用函数的底层的内部方法 [[Call]] 来执行函数体并返回结果的，因此可以将 [obj.]func() 形式的函数调用理解为 func.call() 形式的函数调用，方便记忆。 作为构造函数调用 new 操作符通常用于调用构造函数。通过 new 操作符调用函数时，会创建一个新对象，并且该对象的原型对象指向函数的 prototype 属性，同时 this 会指向该对象，（当返回值为值类型时）函数会默认返回 this。 1234567891011var Person = function(name) &#123; this.name = name&#125;Person.prototype.sayName = function() &#123; console.log(this.name)&#125;var person = new Person('Ricky')person.sayName() // Ricky 查看 ES 标准中的 The new Operator 小节可以看到 new 操作符的工作原理，它调用了函数的内部方法 [[Construct]]。 箭头函数 ES6 新增的箭头函数的一个重要特性，就是箭头函数并没有自己的 this 对象，调用箭头函数时，我们在箭头函数内部引用的 this 实际上来自于箭头函数词法作用域链的上层。 12345678910var name = 'Window'var person = &#123; name: 'Ricky', sayName: () =&gt; &#123; console.log(this.name) &#125;&#125;person.sayName() // Window 参考内容 Standard ECMA-262 Understanding JavaScript Function Invocation and &quot;this&quot;","categories":[{"name":"Tech Notes","slug":"Tech-Notes","permalink":"https://Rickkkkkky.github.io/categories/Tech-Notes/"},{"name":"JavaScript Essence","slug":"Tech-Notes/JavaScript-Essence","permalink":"https://Rickkkkkky.github.io/categories/Tech-Notes/JavaScript-Essence/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://Rickkkkkky.github.io/tags/JavaScript/"}]}]}